% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clusterCVR.R
\name{clusterCVR}
\alias{clusterCVR}
\alias{.cluster}
\title{Cluster CVR data with a EM algorithm}
\usage{
clusterCVR(
  data,
  user_K = 3,
  loglik_thresh = 1e-05,
  runs = 1,
  n_iter = Inf,
  fast = FALSE,
  IIA = FALSE,
  init = "kmeans",
  subset = NULL,
  ignore_X = FALSE,
  recode_key = NULL,
  seed = 2138,
  verbose = TRUE,
  pi = NULL,
  mu = NULL,
  zeta_hat = NULL
)

.cluster(data, user_K, seed, n_iter, loglik_thresh, fast, IIA, init, verbose)
}
\arguments{
\item{data}{the dataset, in list form, with the following slots.
\describe{
\item{\code{y}}{A n by K matrix of split indicators}
\item{\code{m}}{A n by K matrix of missingness indicators. 3 means no missing,
2 means only straight is available, and 1 means only split is available.}
\item{\code{X}}{An optional n by P matrix of covariates with respondent-specific covariates.}
\item{\code{n_u}}{An integer scalar for the number of voters}
\item{\code{L}}{An integer scalar for the number of possible y values (0-indexed)}
\item{\code{uy}}{A n by K matrix of unique profiles y, needed if fast = TRUE}
}}

\item{user_K}{the number of clusters to presume / compute}

\item{loglik_thresh}{the threshold value for convergence. The EM will stop when the
\emph{relative} change in log likelihood is less than the threshold.}

\item{runs}{Number of replications (with different starting values to run). Default is
1 but more than 1 is highly recommended if computing time is not prohibitive.}

\item{n_iter}{manual limit to iterations}

\item{fast}{summarize data to unique profiles, so estimation is faster? Currently
only possible if IIA = FALSE. Defaults to \code{FALSE}.}

\item{IIA}{assume that the data$y matrix is generated from a varying choice set
as defined by data$m? Defaults to \code{FALSE}.}

\item{init}{method of initialization}

\item{subset}{A vector of row indices or row names to subset all the data by.
Useful when wanting to test a small subset of the data without modifying the
\code{data} list. If \code{fast = TRUE}, it will subset \code{n_u} and \code{uy},
If \code{fast = FALSE}, it will subset \code{y}.}

\item{ignore_X}{Should X be set to NULL even if it is provided? Useful when
switching between covariates and non-covariates case. Defaults to \code{FALSE}.}

\item{recode_key}{A named vector to be passed on to \code{dplyr::recode}, in the
form \code{(old1 = new1, old2 = new2, ...)}}

\item{seed}{seed for initialization}

\item{verbose}{Defaults to TRUE.}

\item{pi, mu, zeta_hat}{initial values of the key parameters, if there
are any good guesses. If left \code{NULL}, it  will initialize based on the
method in \code{"init"}.  Follow the format of the output.}
}
\value{
\describe{
\item{ests}{The last iteration}
\item{iters}{Stored iterations}
\item{aux}{A list of stored items not specific to iterations. These include
the initial values, parameters, total time data, and settings.}
\item{seeds_run}{A vector of \code{runs} seeds that were used.}
\item{loglik_run}{A vector of \code{runs} final loglikelihood estimates corresponding
to each run of the model. Only The model with the highest log likelihood is stored.}
}
}
\description{
Compute cluster assignment probabilities by a EM algorithm. The required
inputs are a numeric data matrix and the number of clusters.
}
\details{
See \link{fmt_mu_viz} for a quick way to visualize the output.
}
\examples{
em_full <- clusterCVR(simdata_full, init = "kmeans", runs = 2)

summary(em_full)

\dontrun{
 pars <- summ_params(em_full)
 graph_trend(pars, simdata_full)
}

em_miss  <- clusterCVR(simdata_miss, IIA = TRUE)

}
\keyword{internal}
